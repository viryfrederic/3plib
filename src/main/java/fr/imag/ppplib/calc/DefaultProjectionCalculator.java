/** Polygonal Planar Projection LIBrary (3plib) v0.1.0
 ** Copyright © 2016 Frédéric Viry
 ** author: Frédéric Viry (Laboratoire Verimag, Grenoble, France)
 ** mail: ask3plib@gmail.com
 **
 ** This file is part of 3plib.
 **
 ** 3plib is free software: you can redistribute it and/or modify
 ** it under the terms of the GNU Lesser General Public License as published by
 ** the Free Software Foundation, either version 3 of the License, or
 ** at your option) any later version.
 ** 
 ** 3plib is distributed in the hope that it will be useful,
 ** but WITHOUT ANY WARRANTY; without even the implied warranty of
 ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ** GNU Lesser General Public License for more details.
 ** 
 ** You should have received a copy of the GNU Lesser General Public License
 ** along with 3plib. If not, see <http://www.gnu.org/licenses/>.
 **/

package fr.imag.ppplib.calc;

/** A default implementation for the ProjectionCalculator, using the DefaultVectorCalculator.
 **/

public class DefaultProjectionCalculator implements ProjectionCalculator
{
    /** Create a new ProjectionCalculator to the plane generated by p1 and p2. {p1, p2} must be an orthonormal basis.
     ** @param p1 the first basis vector.
     ** @param p2 the second basis vector.
     **/
    public DefaultProjectionCalculator(double[] p1, double[] p2)
    {
        if (p1 == null || p2 == null)
            emptyPC = true;
        else
        {
            if (p1.length != p2.length)
                throw new ProjectionCalculatorException(nsvsp1p2Message);
            if (vc.areColinears(p1, p2))
                throw new ProjectionCalculatorException(cp1p2Message);
            if (vc.isZeroVector(p1) || vc.isZeroVector(p2))
                throw new ProjectionCalculatorException(zvMessage);
            this.p1 = p1;
            this.p2 = p2;
        }
    }
    
    @Override
    public int getDimension()
    {
        return p1.length;
    }
    
    @Override
    public double[] planarProjection(double[] a)
    {
        /* exception test */
        if (a.length != p1.length)
            throw new ProjectionCalculatorException(nsvsMessage);
        
        /* calculus and return */
        return new double[] {vc.dotProduct(a, p1), vc.dotProduct(a, p2)};
    }
    
    @Override
    public double[] toOriginalSpace(double[] a2d)
    {
        if (a2d.length != 2)
            throw new ProjectionCalculatorException(n2dMessage);
        return vc.sum(vc.multiplyByScalar(a2d[0], p1), vc.multiplyByScalar(a2d[1], p2));
    }
    
    @Override
    public ProjectionCalculator newInstance(double[] p1, double[] p2)
    {
        return new DefaultProjectionCalculator(p1, p2);
    }
    
    @Override
    public ProjectionCalculator clone()
    {
        if (emptyPC)
            throw new ProjectionCalculatorException(npaMessage);
        DefaultProjectionCalculator res = new DefaultProjectionCalculator(p1, p2);
        return res;
    }
    
    private VectorCalculator vc = new DefaultVectorCalculator();
    private double[] p1;
    private double[] p2;
    private boolean emptyPC = false; // Usefull (cf ImplementationFactory)
    private static final String nsvsMessage = "The given vector doesn't live in the same vectorspace than the plane.";
    private static final String nsvsp1p2Message = "Two different dimensions vectors cannot define a plane.";
    private static final String cp1p2Message = "Two colinears vectors cannot define a plane.";
    private static final String npaMessage = "No plane has been attributed to this projection calculator, create a new instance.";
    private static final String n2dMessage = "The given vector is not a 2d vector.";
    private static final String zvMessage = "A zero vector cannot define a plane.";
}
